"""
STRINGS File Generator for CC-Packer (DEPRECATED)

NOTE: As of v1.0.3, this module is no longer used in the merge process.
The original CC STRINGS files are preserved inside the merged BA2 archives,
and the original CC plugins (cc*.esl) handle their own localization.

This module is kept for reference and potential future use.

---

This module handles the generation of STRINGS, DLSTRINGS, and ILSTRINGS files
for merged Creation Club content. These files are required to prevent 
"LOOKUP FAILED!" errors in Fallout 4 when using merged CC archives.

File Format (based on Bethesda's String Table format):
- Header: uint32 count, uint32 data_size
- Directory: [uint32 string_id, uint32 offset] * count
- Data: String data (null-terminated for .STRINGS, length-prefixed for DL/IL)

Reference: https://en.uesp.net/wiki/Skyrim_Mod:String_Table_File_Format

LOCALIZATION SUPPORT:
---------------------
The ESL files generated by CC-Packer have the Localized flag (0x80) set, which
means Fallout 4 will look for STRINGS files in the Data/Strings folder.

By default, we generate English strings:
  - CCMerged_en.STRINGS
  - CCMerged_en.DLSTRINGS  
  - CCMerged_en.ILSTRINGS

To create translations, simply copy these files and rename with your language code:
  - CCMerged_de.STRINGS (German)
  - CCMerged_fr.STRINGS (French)
  - CCMerged_es.STRINGS (Spanish)
  - CCMerged_it.STRINGS (Italian)
  - CCMerged_ja.STRINGS (Japanese)
  - CCMerged_pl.STRINGS (Polish)
  - CCMerged_pt.STRINGS (Portuguese)
  - CCMerged_ru.STRINGS (Russian)
  - CCMerged_zh.STRINGS (Chinese)

Then use a tool like xTranslator to edit the translated text while preserving
the String IDs. The game will automatically load the correct language based on
your Fallout4.ini settings (sLanguage=en, sLanguage=de, etc.)

ACKNOWLEDGMENTS:
----------------
Thanks to MGuffin's xTranslator (https://github.com/MGuffin/xTranslator) for 
documenting the STRINGS file format and providing reference for localization.
"""

import os
import struct
import logging
from pathlib import Path
from typing import Dict, List, Tuple, Optional, BinaryIO, Callable
import subprocess
import tempfile
import shutil

logger = logging.getLogger("CCPacker.Strings")

# Supported Fallout 4 language codes
SUPPORTED_LANGUAGES = [
    "en",  # English (default)
    "de",  # German
    "es",  # Spanish
    "fr",  # French
    "it",  # Italian
    "ja",  # Japanese
    "pl",  # Polish
    "pt",  # Portuguese (Brazil)
    "ru",  # Russian
    "zh",  # Chinese (Simplified)
]


class StringEntry:
    """Represents a single string entry with its ID and text."""
    def __init__(self, string_id: int, text: str):
        self.string_id = string_id
        self.text = text
    
    def __repr__(self):
        return f"StringEntry({self.string_id}, {self.text[:30]}...)" if len(self.text) > 30 else f"StringEntry({self.string_id}, {self.text})"


class StringsFile:
    """
    Handles reading and writing Bethesda STRINGS file format.
    
    Supports three file types:
    - .STRINGS: Simple null-terminated strings (used for names)
    - .DLSTRINGS: Length-prefixed strings (used for descriptions/books)
    - .ILSTRINGS: Length-prefixed strings (used for dialogue)
    """
    
    def __init__(self, file_type: str = "STRINGS"):
        """
        Initialize a StringsFile handler.
        
        Args:
            file_type: One of "STRINGS", "DLSTRINGS", or "ILSTRINGS"
        """
        self.file_type = file_type.upper()
        self.entries: Dict[int, str] = {}  # string_id -> text
        
    def add_entry(self, string_id: int, text: str):
        """Add or update a string entry."""
        if string_id in self.entries:
            # If duplicate ID, keep the longer/non-empty string
            if len(text) > len(self.entries[string_id]):
                self.entries[string_id] = text
        else:
            self.entries[string_id] = text
    
    def merge_from(self, other: 'StringsFile'):
        """Merge entries from another StringsFile."""
        for string_id, text in other.entries.items():
            self.add_entry(string_id, text)
    
    @classmethod
    def read_from_file(cls, filepath: Path) -> 'StringsFile':
        """
        Read a STRINGS/DLSTRINGS/ILSTRINGS file.
        
        Args:
            filepath: Path to the strings file
            
        Returns:
            StringsFile object with parsed entries
        """
        file_type = filepath.suffix.upper().lstrip('.')
        strings_file = cls(file_type)
        
        with open(filepath, 'rb') as f:
            # Read header
            count = struct.unpack('<I', f.read(4))[0]
            data_size = struct.unpack('<I', f.read(4))[0]
            
            # Read directory
            directory: List[Tuple[int, int]] = []
            for _ in range(count):
                string_id = struct.unpack('<I', f.read(4))[0]
                offset = struct.unpack('<I', f.read(4))[0]
                directory.append((string_id, offset))
            
            # Calculate data start position
            data_start = 8 + (count * 8)
            
            # Read string data
            for string_id, offset in directory:
                f.seek(data_start + offset)
                
                if file_type == "STRINGS":
                    # Null-terminated string
                    text = cls._read_null_terminated_string(f)
                else:
                    # Length-prefixed string (DLSTRINGS, ILSTRINGS)
                    length = struct.unpack('<I', f.read(4))[0]
                    if length > 0:
                        text_bytes = f.read(length - 1)  # -1 for null terminator
                        f.read(1)  # Read null terminator
                        text = text_bytes.decode('utf-8', errors='replace')
                    else:
                        text = ""
                
                strings_file.entries[string_id] = text
        
        return strings_file
    
    @staticmethod
    def _read_null_terminated_string(f: BinaryIO) -> str:
        """Read a null-terminated string from file."""
        chars = []
        while True:
            c = f.read(1)
            if c == b'\x00' or c == b'':
                break
            chars.append(c)
        return b''.join(chars).decode('utf-8', errors='replace')
    
    def write_to_file(self, filepath: Path):
        """
        Write entries to a STRINGS/DLSTRINGS/ILSTRINGS file.
        
        Args:
            filepath: Output path for the strings file
        """
        if not self.entries:
            logger.warning(f"No entries to write for {filepath}")
            return
        
        # Sort entries by string ID for consistent output
        sorted_entries = sorted(self.entries.items(), key=lambda x: x[0])
        
        # Build string data and directory
        string_data = bytearray()
        directory: List[Tuple[int, int]] = []
        
        for string_id, text in sorted_entries:
            offset = len(string_data)
            directory.append((string_id, offset))
            
            # Encode string as UTF-8
            text_bytes = text.encode('utf-8')
            
            if self.file_type == "STRINGS":
                # Null-terminated string
                string_data.extend(text_bytes)
                string_data.append(0)  # Null terminator
            else:
                # Length-prefixed string (DLSTRINGS, ILSTRINGS)
                length = len(text_bytes) + 1  # +1 for null terminator
                string_data.extend(struct.pack('<I', length))
                string_data.extend(text_bytes)
                string_data.append(0)  # Null terminator
        
        # Ensure parent directory exists
        filepath.parent.mkdir(parents=True, exist_ok=True)
        
        # Write file
        with open(filepath, 'wb') as f:
            # Header
            f.write(struct.pack('<I', len(directory)))  # Count
            f.write(struct.pack('<I', len(string_data)))  # Data size
            
            # Directory
            for string_id, offset in directory:
                f.write(struct.pack('<I', string_id))
                f.write(struct.pack('<I', offset))
            
            # String data
            f.write(string_data)
        
        logger.info(f"Wrote {len(directory)} strings to {filepath}")


class CCStringsExtractor:
    """
    Extracts localized strings from Creation Club BA2 archives.
    
    CC content stores strings in BA2 archives under:
    - Strings/<PluginName>_en.STRINGS
    - Strings/<PluginName>_en.DLSTRINGS  
    - Strings/<PluginName>_en.ILSTRINGS
    """
    
    def __init__(self, archive2_path: str):
        """
        Initialize the extractor.
        
        Args:
            archive2_path: Path to Archive2.exe
        """
        self.archive2_path = archive2_path
    
    def extract_strings_from_ba2(self, ba2_path: Path, output_dir: Path) -> Dict[str, Path]:
        """
        Extract STRINGS files from a BA2 archive.
        
        Args:
            ba2_path: Path to the BA2 archive
            output_dir: Directory to extract files to
            
        Returns:
            Dict mapping file type to extracted file path
        """
        extracted = {}
        
        try:
            # Extract the entire archive
            result = subprocess.run(
                [self.archive2_path, str(ba2_path), f"-e={output_dir}"],
                check=True,
                capture_output=True,
                text=True
            )
            
            # Find extracted strings files
            strings_dir = output_dir / "Strings"
            if strings_dir.exists():
                for strings_file in strings_dir.glob("*"):
                    suffix = strings_file.suffix.upper()
                    if suffix in ['.STRINGS', '.DLSTRINGS', '.ILSTRINGS']:
                        extracted[suffix] = strings_file
                        
        except subprocess.CalledProcessError as e:
            logger.warning(f"Failed to extract {ba2_path}: {e}")
        except Exception as e:
            logger.warning(f"Error extracting {ba2_path}: {e}")
        
        return extracted


class CCStringsGenerator:
    """
    Extracts and preserves STRINGS files for CC-Packer.
    
    When CC BA2 archives are merged, the original STRINGS files inside them
    are lost. This class extracts those STRINGS files and places them in
    Data/Strings so the original CC plugins can still find their localized text.
    
    The original CC plugins (cc*.esl) still reference their own string IDs,
    so we must preserve the original STRINGS files with their original names.
    """
    
    def __init__(self, fo4_path: str, archive2_path: str):
        """
        Initialize the generator.
        
        Args:
            fo4_path: Path to Fallout 4 installation
            archive2_path: Path to Archive2.exe
        """
        self.fo4_path = Path(fo4_path)
        self.data_path = self.fo4_path / "Data"
        self.archive2_path = archive2_path
        self.extractor = CCStringsExtractor(archive2_path)
        """
        Initialize the generator.
        
        Args:
            fo4_path: Path to Fallout 4 installation
            archive2_path: Path to Archive2.exe
        """
        self.fo4_path = Path(fo4_path)
        self.data_path = self.fo4_path / "Data"
        self.archive2_path = archive2_path
        self.extractor = CCStringsExtractor(archive2_path)
        
        # Merged strings storage
        self.strings = StringsFile("STRINGS")
        self.dlstrings = StringsFile("DLSTRINGS")
        self.ilstrings = StringsFile("ILSTRINGS")
    
    def find_cc_archives(self) -> List[Path]:
        """Find all CC BA2 archives that may contain strings."""
        cc_files = []
        
        # Look for Main archives (these contain the strings folder)
        for ba2_file in self.data_path.glob("cc*-Main.ba2"):
            # Skip our merged archives
            if not ba2_file.name.lower().startswith("ccmerged"):
                cc_files.append(ba2_file)
        
        # Also check for archives without the -Main suffix
        for ba2_file in self.data_path.glob("cc*.ba2"):
            if "-" not in ba2_file.name and not ba2_file.name.lower().startswith("ccmerged"):
                cc_files.append(ba2_file)
        
        return sorted(set(cc_files))
    
    def extract_and_merge_strings(self, progress_callback=None) -> bool:
        """
        Extract strings from all CC archives and merge them.
        
        Args:
            progress_callback: Optional callback for progress updates
            
        Returns:
            True if successful, False otherwise
        """
        cc_archives = self.find_cc_archives()
        
        if not cc_archives:
            if progress_callback:
                progress_callback("No CC archives found with strings to extract.")
            return True  # Not an error, just nothing to do
        
        if progress_callback:
            progress_callback(f"Found {len(cc_archives)} CC archives to scan for strings...")
        
        # Create temp directory for extraction
        temp_dir = self.data_path / "CC_Temp_Strings"
        if temp_dir.exists():
            shutil.rmtree(temp_dir)
        temp_dir.mkdir(parents=True)
        
        try:
            strings_found = 0
            
            for i, ba2_path in enumerate(cc_archives):
                if progress_callback:
                    progress_callback(f"Extracting strings [{i+1}/{len(cc_archives)}]: {ba2_path.name}")
                
                # Extract to a subdirectory for this archive
                archive_temp = temp_dir / ba2_path.stem
                archive_temp.mkdir(exist_ok=True)
                
                extracted = self.extractor.extract_strings_from_ba2(ba2_path, archive_temp)
                
                # Merge extracted strings
                for suffix, filepath in extracted.items():
                    try:
                        if suffix == '.STRINGS':
                            source = StringsFile.read_from_file(filepath)
                            self.strings.merge_from(source)
                            strings_found += len(source.entries)
                        elif suffix == '.DLSTRINGS':
                            source = StringsFile.read_from_file(filepath)
                            self.dlstrings.merge_from(source)
                            strings_found += len(source.entries)
                        elif suffix == '.ILSTRINGS':
                            source = StringsFile.read_from_file(filepath)
                            self.ilstrings.merge_from(source)
                            strings_found += len(source.entries)
                    except Exception as e:
                        logger.warning(f"Failed to read {filepath}: {e}")
            
            if progress_callback:
                progress_callback(f"Merged {strings_found} string entries from CC content.")
            
            return True
            
        finally:
            # Cleanup temp directory
            if temp_dir.exists():
                shutil.rmtree(temp_dir)
    
    def generate_strings_files(self, esl_names: List[str], progress_callback=None) -> List[Path]:
        """
        Generate STRINGS files for the merged ESL plugins.
        
        Args:
            esl_names: List of ESL filenames (e.g., ["CCMerged.esl"])
            progress_callback: Optional callback for progress updates
            
        Returns:
            List of generated file paths
        """
        generated_files = []
        
        # Create Strings directory if needed
        strings_dir = self.data_path / "Strings"
        strings_dir.mkdir(parents=True, exist_ok=True)
        
        for esl_name in esl_names:
            # Remove .esl extension to get base name
            base_name = esl_name.rsplit('.', 1)[0]
            
            if progress_callback:
                progress_callback(f"Generating STRINGS files for {esl_name}...")
            
            # Generate all three string file types
            if self.strings.entries:
                strings_path = strings_dir / f"{base_name}_en.STRINGS"
                self.strings.write_to_file(strings_path)
                generated_files.append(strings_path)
            
            if self.dlstrings.entries:
                dlstrings_path = strings_dir / f"{base_name}_en.DLSTRINGS"
                self.dlstrings.write_to_file(dlstrings_path)
                generated_files.append(dlstrings_path)
            
            if self.ilstrings.entries:
                ilstrings_path = strings_dir / f"{base_name}_en.ILSTRINGS"
                self.ilstrings.write_to_file(ilstrings_path)
                generated_files.append(ilstrings_path)
        
        if progress_callback:
            total_entries = len(self.strings.entries) + len(self.dlstrings.entries) + len(self.ilstrings.entries)
            progress_callback(f"Generated {len(generated_files)} STRINGS files with {total_entries} total entries.")
        
        return generated_files
    
    def generate_for_merged_content(self, esl_names: List[str], cc_ba2_files: List[Path], progress_callback=None) -> List[Path]:
        """
        Complete workflow: Extract strings from CC archives and generate merged STRINGS files.
        
        This is the main entry point for strings generation during the merge process.
        
        Args:
            esl_names: List of ESL filenames we're generating strings for
            cc_ba2_files: List of original CC BA2 files being merged
            progress_callback: Optional callback for progress updates
            
        Returns:
            List of generated STRINGS file paths
        """
        if progress_callback:
            progress_callback("Starting STRINGS file generation...")
        
        # Filter to only Main archives (which contain strings)
        main_archives = [f for f in cc_ba2_files if 'main' in f.name.lower() or '-' not in f.name.lower()]
        
        if not main_archives:
            if progress_callback:
                progress_callback("No archives with strings data found.")
            return []
        
        # Extract and merge strings from source archives
        temp_dir = self.data_path / "CC_Temp_Strings"
        if temp_dir.exists():
            shutil.rmtree(temp_dir)
        temp_dir.mkdir(parents=True)
        
        try:
            strings_found = 0
            
            for i, ba2_path in enumerate(main_archives):
                if progress_callback:
                    progress_callback(f"Scanning for strings [{i+1}/{len(main_archives)}]: {ba2_path.name}")
                
                # Extract to a subdirectory
                archive_temp = temp_dir / ba2_path.stem
                archive_temp.mkdir(exist_ok=True)
                
                extracted = self.extractor.extract_strings_from_ba2(ba2_path, archive_temp)
                
                for suffix, filepath in extracted.items():
                    try:
                        if suffix == '.STRINGS':
                            source = StringsFile.read_from_file(filepath)
                            self.strings.merge_from(source)
                            strings_found += len(source.entries)
                        elif suffix == '.DLSTRINGS':
                            source = StringsFile.read_from_file(filepath)
                            self.dlstrings.merge_from(source)
                            strings_found += len(source.entries)
                        elif suffix == '.ILSTRINGS':
                            source = StringsFile.read_from_file(filepath)
                            self.ilstrings.merge_from(source)
                            strings_found += len(source.entries)
                    except Exception as e:
                        logger.warning(f"Failed to read {filepath}: {e}")
            
            if strings_found == 0:
                if progress_callback:
                    progress_callback("No localized strings found in CC archives.")
                return []
            
            if progress_callback:
                progress_callback(f"Found {strings_found} string entries. Generating output files...")
            
            # Generate the output files
            return self.generate_strings_files(esl_names, progress_callback)
            
        finally:
            # Cleanup
            if temp_dir.exists():
                shutil.rmtree(temp_dir)


def generate_strings_for_merge(fo4_path: str, archive2_path: str, esl_names: List[str], 
                                cc_ba2_files: List[Path], progress_callback=None) -> List[Path]:
    """
    Convenience function to generate STRINGS files for a CC merge operation.
    
    Args:
        fo4_path: Path to Fallout 4 installation
        archive2_path: Path to Archive2.exe
        esl_names: List of ESL filenames (e.g., ["CCMerged.esl"])
        cc_ba2_files: List of original CC BA2 files being merged
        progress_callback: Optional callback for progress updates
        
    Returns:
        List of generated STRINGS file paths
    """
    generator = CCStringsGenerator(fo4_path, archive2_path)
    return generator.generate_for_merged_content(esl_names, cc_ba2_files, progress_callback)
